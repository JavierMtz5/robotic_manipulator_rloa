<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>robotic_manipulator_rloa.environment.environment API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0;color:#058}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>robotic_manipulator_rloa.environment.environment</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import random
from typing import List, Tuple

import numpy as np
import pybullet as p
import pybullet_data
from numpy.typing import NDArray

from robotic_manipulator_rloa.utils.logger import get_global_logger
from robotic_manipulator_rloa.utils.exceptions import (
    InvalidManipulatorFile,
    InvalidEnvironmentParameter
)
from robotic_manipulator_rloa.utils.collision_detector import CollisionObject, CollisionDetector

logger = get_global_logger()


class EnvironmentConfiguration:

    def __init__(self,
                 endeffector_index: int,
                 fixed_joints: List[int],
                 involved_joints: List[int],
                 target_position: List[float],
                 obstacle_position: List[float],
                 initial_joint_positions: List[float] = None,
                 initial_positions_variation_range: List[float] = None,
                 max_force: float = 200.,
                 visualize: bool = True):
        &#34;&#34;&#34;
        Validates each of the parameters required for the Environment class initialization.
        Args:
            endeffector_index: Index of the manipulator&#39;s end-effector.
            fixed_joints: List containing the indices of every joint not involved in the training.
            involved_joints: List containing the indices of every joint involved in the training.
            target_position: List containing the position of the target object, as 3D Cartesian coordinates.
            obstacle_position: List containing the position of the obstacle, as 3D Cartesian coordinates.
            initial_joint_positions: List containing as many items as the number of joints of the manipulator.
                Each item in the list corresponds to the initial position wanted for the joint with that same index.
            initial_positions_variation_range: List containing as many items as the number of joints of the manipulator.
                Each item in the list corresponds to the variation range wanted for the joint with that same index.
            max_force: Maximum force to be applied on the joints.
            visualize: Visualization mode.
        &#34;&#34;&#34;
        self._validate_endeffector_index(endeffector_index)
        self._validate_fixed_joints(fixed_joints)
        self._validate_involved_joints(involved_joints)
        self._validate_target_position(target_position)
        self._validate_obstacle_position(obstacle_position)
        self._validate_initial_joint_positions(initial_joint_positions)
        self._validate_initial_positions_variation_range(initial_positions_variation_range)
        self._validate_max_force(max_force)
        self._validate_visualize(visualize)

    def _validate_endeffector_index(self, endeffector_index: int) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;endeffector_index&#34; parameter.
        Args:
            endeffector_index: int
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(endeffector_index, int):
            raise InvalidEnvironmentParameter(&#39;End Effector index received is not an integer&#39;)
        self.endeffector_index = endeffector_index

    def _validate_fixed_joints(self, fixed_joints: List[int]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;fixed_joints&#34; parameter
        Args:
            fixed_joints: list of integers
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(fixed_joints, list):
            raise InvalidEnvironmentParameter(&#39;Fixed Joints received is not a list&#39;)
        for val in fixed_joints:
            if not isinstance(val, int):
                raise InvalidEnvironmentParameter(&#39;An item inside the Fixed Joints list is not an integer&#39;)
        self.fixed_joints = fixed_joints

    def _validate_involved_joints(self, involved_joints: List[int]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;involved_joints&#34; parameter
        Args:
            involved_joints: list of integers
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(involved_joints, list):
            raise InvalidEnvironmentParameter(&#39;Involved Joints received is not a list&#39;)
        for val in involved_joints:
            if not isinstance(val, int):
                raise InvalidEnvironmentParameter(&#39;An item inside the Involved Joints list is not an integer&#39;)
        self.involved_joints = involved_joints

    def _validate_target_position(self, target_position: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;target_position&#34; parameter
        Args:
            target_position: list of floats
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(target_position, list):
            raise InvalidEnvironmentParameter(&#39;Target Position received is not a list&#39;)
        for val in target_position:
            if not isinstance(val, (int, float)):
                raise InvalidEnvironmentParameter(&#39;An item inside the Target Position list is not a float&#39;)
        self.target_position = target_position

    def _validate_obstacle_position(self, obstacle_position: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;obstacle_position&#34; parameter
        Args:
            obstacle_position: list of floats
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(obstacle_position, list):
            raise InvalidEnvironmentParameter(&#39;Obstacle Position received is not a list&#39;)
        for val in obstacle_position:
            if not isinstance(val, (int, float)):
                raise InvalidEnvironmentParameter(&#39;An item inside the Obstacle Position list is not a float&#39;)
        self.obstacle_position = obstacle_position

    def _validate_initial_joint_positions(self, initial_joint_positions: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;initial_joint_positions&#34; parameter
        Args:
            initial_joint_positions: list of floats
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if initial_joint_positions is None:
            self.initial_joint_positions = None
            return
        if not isinstance(initial_joint_positions, list):
            raise InvalidEnvironmentParameter(&#39;Initial Joint Positions received is not a list&#39;)
        for val in initial_joint_positions:
            if not isinstance(val, (int, float)):
                raise InvalidEnvironmentParameter(&#39;An item inside the Initial Joint Positions list is not a float&#39;)
        self.initial_joint_positions = initial_joint_positions

    def _validate_initial_positions_variation_range(self, initial_positions_variation_range: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;initial_positions_variation_range&#34; parameter
        Args:
            initial_positions_variation_range: list of floats
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if initial_positions_variation_range is None:
            self.initial_positions_variation_range = None
            return
        if not isinstance(initial_positions_variation_range, list):
            raise InvalidEnvironmentParameter(&#39;Initial Positions Variation Range received is not a list&#39;)
        for val in initial_positions_variation_range:
            if not isinstance(val, (float, int)):
                raise InvalidEnvironmentParameter(&#39;An item inside the Initial Positions Variation Range &#39;
                                                  &#39;list is not a float&#39;)
        self.initial_positions_variation_range = initial_positions_variation_range

    def _validate_max_force(self, max_force: float) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;max_force&#34; parameter
        Args:
            max_force: float
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(max_force, (int, float)):
            raise InvalidEnvironmentParameter(&#39;Maximum Force value received is not a float&#39;)
        self.max_force = max_force

    def _validate_visualize(self, visualize: bool) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;visualize&#34; parameter
        Args:
            visualize: bool
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(visualize, bool):
            raise InvalidEnvironmentParameter(&#39;Visualize value received is not a boolean&#39;)
        self.visualize = visualize


class Environment:

    def __init__(self,
                 manipulator_file: str,
                 environment_config: EnvironmentConfiguration):
        &#34;&#34;&#34;
        Creates the Pybullet environment used along the training.
        Args:
            manipulator_file: Path to the URDF or SDF file from which to load the Robotic Manipulator.
            environment_config: Instance of the EnvironmentConfiguration class with all its attributes set.
        Raises:
            InvalidManipulatorFile: The URDF/SDF file doesn&#39;t exist, is invalid or has an invalid extension.
        &#34;&#34;&#34;
        self.manipulator_file = manipulator_file
        self.visualize = environment_config.visualize

        # Initialize pybullet
        self.physics_client = p.connect(p.GUI if environment_config.visualize else p.DIRECT)
        p.setGravity(0, 0, -9.81)
        p.setRealTimeSimulation(0)
        p.setAdditionalSearchPath(pybullet_data.getDataPath())

        self.target_pos = environment_config.target_position
        self.obstacle_pos = environment_config.obstacle_position
        self.max_force = environment_config.max_force  # Maximum force to be applied (DEFAULT=200)
        self.initial_joint_positions = environment_config.initial_joint_positions
        self.initial_positions_variation_range = environment_config.initial_positions_variation_range

        self.endeffector_index = environment_config.endeffector_index  # Index of the Manipulator&#39;s End-Effector
        self.fixed_joints = environment_config.fixed_joints  # List of indexes for the joints to be fixed
        self.involved_joints = environment_config.involved_joints  # List of indexes of joints involved in the training

        # Load Manipulator from URDF/SDF file
        logger.debug(f&#39;Loading URDF/SDF file {manipulator_file} for Robot Manipulator...&#39;)
        if not isinstance(manipulator_file, str):
            raise InvalidManipulatorFile(&#39;The filename provided is not a string&#39;)

        try:
            if manipulator_file.endswith(&#39;.urdf&#39;):
                self.manipulator_uid = p.loadURDF(manipulator_file)
            elif manipulator_file.endswith(&#39;.sdf&#39;):
                self.manipulator_uid = p.loadSDF(manipulator_file)[0]
            else:
                raise InvalidManipulatorFile(&#39;The file extension is neither .sdf nor .urdf&#39;)
        except p.error as err:
            logger.critical(err)
            raise InvalidManipulatorFile

        self.num_joints = p.getNumJoints(self.manipulator_uid)

        logger.debug(f&#39;Robot Manipulator URDF/SDF file {manipulator_file} has been successfully loaded. &#39;
                     f&#39;The Robot Manipulator has {self.num_joints} joints, and its joints, &#39;
                     f&#39;together with the information of each, are:&#39;)
        data = list()
        for joint_ind in range(self.num_joints):
            joint_info = p.getJointInfo(self.manipulator_uid, joint_ind)
            data.append((joint_ind, joint_info[1].decode(&#34;utf-8&#34;), joint_info[9], joint_info[8], joint_info[13]))

        # Print Joints info
        self.print_table(data)

        # Create obstacle with the shape of a sphere, and the target object with square shape
        self.obstacle = p.loadURDF(&#39;sphere_small.urdf&#39;, basePosition=self.obstacle_pos,
                                   useFixedBase=1, globalScaling=2.5)
        self.target = p.loadURDF(&#39;cube_small.urdf&#39;, basePosition=self.target_pos,
                                 useFixedBase=1, globalScaling=1)
        logger.debug(f&#39;Both the obstacle and the target object have been generated in positions {self.obstacle_pos} &#39;
                     f&#39;and {self.target_pos} respectively&#39;)

        # 9 elements correspond to the 3 vector indicating the position of the target, end effector and obstacle
        # The other elements are the two arrays of the involved joint&#39;s position and velocities
        self._observation_space = np.zeros((9 + 2 * len(self.involved_joints),))
        self._action_space = np.zeros((len(self.involved_joints),))

    def reset(self, verbose: bool = True) -&gt; NDArray:
        &#34;&#34;&#34;
        Resets the environment to a initial state.\n
        - If &#34;initial_joint_positions&#34; and &#34;initial_positions_variation_range&#34; are not set, all joints will be reset to
        the 0 position.\n
        - If only &#34;initial_joint_positions&#34; is set, the joints will be reset to those positions.\n
        - If only &#34;initial_positions_variation_range&#34; is set, the joints will be reset to 0 plus the variation noise.\n
        - If both &#34;initial_joint_positions&#34; and &#34;initial_positions_variation_range&#34; are set, the joints will be reset
        to the positions specified plus the variation noise.
        Args:
            verbose: Boolean indicating whether to print context information or not.
        Returns:
            New state reached after reset.
        &#34;&#34;&#34;
        if verbose: logger.info(&#39;Resetting Environment...&#39;)

        # Reset the robot&#39;s base position and orientation
        p.resetBasePositionAndOrientation(self.manipulator_uid, [0.000000, 0.000000, 0.000000],
                                          [0.000000, 0.000000, 0.000000, 1.000000])

        if not self.initial_joint_positions and not self.initial_positions_variation_range:
            initial_state = [0 for _ in range(self.num_joints)]
        elif self.initial_joint_positions:
            if self.initial_positions_variation_range:
                initial_state = [random.uniform(pos - var, pos + var) for pos, var
                                 in zip(self.initial_joint_positions, self.initial_positions_variation_range)]
            else:
                initial_state = self.initial_joint_positions
        else:
            initial_state = [random.uniform(0 - var, 0 + var) for var in self.initial_positions_variation_range]

        for joint_index, pos in enumerate(initial_state):
            p.setJointMotorControl2(self.manipulator_uid, joint_index,
                                    controlMode=p.POSITION_CONTROL,
                                    targetPosition=pos)

        for _ in range(50):
            p.stepSimulation(self.physics_client)

        # Generate first state, and return it
        # The states are defined as {joint_pos, joint_vel, end-effector_pos, target_pos, obstacle_pos}, where
        # both joint_pos and joint_vel are arrays with the pos and vel of each joint
        new_state = self.get_state()
        if verbose: logger.info(&#39;Environment Reset&#39;)

        return new_state

    def is_terminal_state(self, target_threshold: float = 0.05, obstacle_threshold: float = 0.,
                          consider_autocollision: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Calculates if a terminal state is reached.
        Args:
            target_threshold: Threshold which delimits the terminal state. If the end-effector is closer
                to the target position than the threshold value, then a terminal state is reached.
            obstacle_threshold: Threshold which delimits the terminal state. If the end-effector is closer
                to the obstacle position than the threshold value, then a terminal state is reached.
            consider_autocollision: If set to True, the collision of any of the joints and parts of the manipulator
                with any other joint or part will be considered a terminal state.
        Returns:
            Integer (0 or 1) indicating whether the new state reached is a terminal state or not.
        &#34;&#34;&#34;
        # If the manipulator has a collision with the obstacle, the episode terminates
        if self.get_manipulator_obstacle_collisions(threshold=obstacle_threshold):
            logger.info(&#39;Collision detected, terminating episode...&#39;)
            return 1

        # If the position of the end-effector is the same as the one of the target position, episode terminates
        if self.get_endeffector_target_collision(threshold=target_threshold)[0]:
            logger.info(&#39;The goal state has been reached, terminating episode...&#39;)
            return 1

        # If the manipulator collides with itself, a terminal state is reached
        if consider_autocollision:
            self_distances = self.get_manipulator_collisions_with_itself()
            for distances in self_distances.values():
                if (distances &lt; 0).any():
                    logger.info(&#39;Auto-Collision detected, terminating episode...&#39;)
                    return 1

        return 0

    def get_reward(self, consider_autocollision: bool = False) -&gt; float:
        &#34;&#34;&#34;
        Computes the reward from the given state.
        Returns:
            Rewards:\n
            - If the end effector reaches the target position, a reward of +250 is returned.\n
            - If the end effector collides with the obstacle or with itself*, a reward of -1000 is returned.\n
            - Otherwise, the negative value of the distance from end effector to the target is returned.\n
            * The manipulator&#39;s collisions with itself are only considered if &#34;consider_autocollision&#34; parameter is set
            to True.
        &#34;&#34;&#34;
        # Auto-Collision is only calculated if requested
        self_collision = False
        if consider_autocollision:
            self_distances = self.get_manipulator_collisions_with_itself()
            for distances in self_distances.values():
                if (distances &lt; 0).any():
                    self_collision = True

        endeffector_target_collision, endeffector_target_dist = self.get_endeffector_target_collision(threshold=0.05)

        if endeffector_target_collision:
            return 250
        elif self.get_manipulator_obstacle_collisions(threshold=0) or self_collision:
            return -1000
        else:
            return -1 * float(endeffector_target_dist)

    def get_manipulator_obstacle_collisions(self, threshold: float) -&gt; bool:
        &#34;&#34;&#34;
        Calculates if there is a collision between the manipulator and the obstacle.
        Args:
            threshold: If the distance between the end effector and the obstacle is below the &#34;threshold&#34;, then
                it is considered a collision.
        Returns:
            Boolean indicating whether a collision occurred.
        &#34;&#34;&#34;
        joint_distances = list()
        for joint_ind in range(self.num_joints):
            end_effector_collision_obj = CollisionObject(body=self.manipulator_uid, link=joint_ind)
            collision_detector = CollisionDetector(collision_object=end_effector_collision_obj,
                                                   obstacle_ids=[self.obstacle])

            dist = collision_detector.compute_distances()
            joint_distances.append(dist[0])

        joint_distances = np.array(joint_distances)
        return (joint_distances &lt; threshold).any()

    def get_manipulator_collisions_with_itself(self) -&gt; dict:
        &#34;&#34;&#34;
        Calculates the distances between each of the manipulator&#39;s joints and the other joints.
        Returns:
            Dictionary where each key is the index of a joint, and where each value is an array with the
            distances from that joint to any other joint in the manipulator.
        &#34;&#34;&#34;
        joint_distances = dict()
        for joint_ind in range(self.num_joints):
            joint_collision_obj = CollisionObject(body=self.manipulator_uid, link=joint_ind)
            collision_detector = CollisionDetector(collision_object=joint_collision_obj,
                                                   obstacle_ids=[])
            distances = collision_detector.compute_collisions_in_manipulator(
                affected_joints=[_ for _ in range(self.num_joints)],  # all joints are taken into account
                max_distance=10
            )
            joint_distances[f&#39;joint_{joint_ind}&#39;] = distances

        return joint_distances

    def get_endeffector_target_collision(self, threshold: float) -&gt; Tuple[bool, float]:
        &#34;&#34;&#34;
        Calculates if there are any collisions between the end effector and the target.
        Args:
            threshold: If the distance between the end effector and the target is below {threshold}, then
                it is considered a collision.
        Returns:
            Tuple where the first element is a boolean indicating whether a collision occurred, adn where
            the second is the distance from end effector to target minus the threshold.
        &#34;&#34;&#34;
        kuka_end_effector = CollisionObject(body=self.manipulator_uid, link=self.endeffector_index)
        collision_detector = CollisionDetector(collision_object=kuka_end_effector, obstacle_ids=[self.target])

        dist = collision_detector.compute_distances()

        return (dist &lt; threshold).any(), dist - threshold

    def get_state(self) -&gt; NDArray:
        &#34;&#34;&#34;
        Retrieves information from the environment&#39;s current state.
        Returns:
            State as (joint_pos, joint_vel, end-effector_pos, target_pos, obstacle_pos):\n
            - The positions of the target, obstacle and end effector are given as 3D cartesian coordinates.\n
            - The joint positions and joint velocities are given as arrays of length equal to the number of
            joint involved in the training.
        &#34;&#34;&#34;
        joint_pos, joint_vel = list(), list()

        for joint_index in range(len(self.involved_joints)):
            joint_pos.append(p.getJointState(self.manipulator_uid, joint_index)[0])
            joint_vel.append(p.getJointState(self.manipulator_uid, joint_index)[1])

        end_effector_pos = p.getLinkState(self.manipulator_uid, self.endeffector_index)[0]
        end_effector_pos = list(end_effector_pos)

        state = np.hstack([np.array(joint_pos), np.array(joint_vel), np.array(end_effector_pos),
                           np.array(self.target_pos), np.array(self.obstacle_pos)])
        return state.astype(float)

    def step(self, action: NDArray) -&gt; Tuple[NDArray, float, int]:
        &#34;&#34;&#34;
        Applies the action on the Robot&#39;s joints, so that each joint reaches the desired velocity for
        each involved joint.
        Args:
            action: Array where each element corresponds to the velocity to be applied on the joint
                with that same index.
        Returns:
            (new_state, reward, done)
        &#34;&#34;&#34;
        # Apply velocities on the involved joints according to action
        for joint_index, vel in zip(self.involved_joints, action):
            p.setJointMotorControl2(self.manipulator_uid,
                                    joint_index,
                                    p.VELOCITY_CONTROL,
                                    targetVelocity=vel,
                                    force=self.max_force)

        # Create constraint for fixed joints (maintain joint on fixed position)
        for joint_ind in self.fixed_joints:
            p.setJointMotorControl2(self.manipulator_uid,
                                    joint_ind,
                                    p.POSITION_CONTROL,
                                    targetPosition=0)

        # Perform actions on simulation
        p.stepSimulation(physicsClientId=self.physics_client)

        reward = self.get_reward()
        new_state = self.get_state()
        done = self.is_terminal_state()

        return new_state, reward, done

    @staticmethod
    def print_table(data: List[Tuple[int, str, float, float, tuple]]) -&gt; None:
        &#34;&#34;&#34;
        Prints a table such that the elements received in the &#34;data&#34; parameter are displayed under
        &#34;Index&#34;, &#34;Name&#34;, &#34;Upper Limit&#34;, &#34;Lower Limit&#34; and &#34;Axis&#34; columns. It is used to print the Manipulator&#39;s
        joint&#39;s information in an ordered manner.
        Args:
            data: List where each element contains all the information about a given joint.
                Each element on the list will be a tuple containing (index, name, upper_limit, lower_limit, axis).
        &#34;&#34;&#34;
        logger.debug(&#39;{:&lt;6} {:&lt;35} {:&lt;15} {:&lt;15} {:&lt;15}&#39;.format(&#39;Index&#39;, &#39;Name&#39;, &#39;Upper Limit&#39;, &#39;Lower Limit&#39;, &#39;Axis&#39;))
        for index, name, up_limit, lo_limit, axis in data:
            logger.debug(&#39;{:&lt;6} {:&lt;35} {:&lt;15} {:&lt;15} {:&lt;15}&#39;.format(index, name, up_limit, lo_limit, str(axis)))

    @property
    def observation_space(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Getter for the observation space of the environment.
        Returns:
            Numpy array of zeros with same shape as the environment&#39;s states.
        &#34;&#34;&#34;
        return self._observation_space

    @property
    def action_space(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Getter for the action space of the environment.
        Returns:
            Numpy array of zeros with same shape as the environment&#39;s actions.
        &#34;&#34;&#34;
        return self._action_space</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="robotic_manipulator_rloa.environment.environment.Environment"><code class="flex name class">
<span>class <span class="ident">Environment</span></span>
<span>(</span><span>manipulator_file: str, environment_config: <a title="robotic_manipulator_rloa.environment.environment.EnvironmentConfiguration" href="#robotic_manipulator_rloa.environment.environment.EnvironmentConfiguration">EnvironmentConfiguration</a>)</span>
</code></dt>
<dd>
<div class="desc"><p>Creates the Pybullet environment used along the training.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>manipulator_file</code></strong></dt>
<dd>Path to the URDF or SDF file from which to load the Robotic Manipulator.</dd>
<dt><strong><code>environment_config</code></strong></dt>
<dd>Instance of the EnvironmentConfiguration class with all its attributes set.</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>InvalidManipulatorFile</code></dt>
<dd>The URDF/SDF file doesn't exist, is invalid or has an invalid extension.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Environment:

    def __init__(self,
                 manipulator_file: str,
                 environment_config: EnvironmentConfiguration):
        &#34;&#34;&#34;
        Creates the Pybullet environment used along the training.
        Args:
            manipulator_file: Path to the URDF or SDF file from which to load the Robotic Manipulator.
            environment_config: Instance of the EnvironmentConfiguration class with all its attributes set.
        Raises:
            InvalidManipulatorFile: The URDF/SDF file doesn&#39;t exist, is invalid or has an invalid extension.
        &#34;&#34;&#34;
        self.manipulator_file = manipulator_file
        self.visualize = environment_config.visualize

        # Initialize pybullet
        self.physics_client = p.connect(p.GUI if environment_config.visualize else p.DIRECT)
        p.setGravity(0, 0, -9.81)
        p.setRealTimeSimulation(0)
        p.setAdditionalSearchPath(pybullet_data.getDataPath())

        self.target_pos = environment_config.target_position
        self.obstacle_pos = environment_config.obstacle_position
        self.max_force = environment_config.max_force  # Maximum force to be applied (DEFAULT=200)
        self.initial_joint_positions = environment_config.initial_joint_positions
        self.initial_positions_variation_range = environment_config.initial_positions_variation_range

        self.endeffector_index = environment_config.endeffector_index  # Index of the Manipulator&#39;s End-Effector
        self.fixed_joints = environment_config.fixed_joints  # List of indexes for the joints to be fixed
        self.involved_joints = environment_config.involved_joints  # List of indexes of joints involved in the training

        # Load Manipulator from URDF/SDF file
        logger.debug(f&#39;Loading URDF/SDF file {manipulator_file} for Robot Manipulator...&#39;)
        if not isinstance(manipulator_file, str):
            raise InvalidManipulatorFile(&#39;The filename provided is not a string&#39;)

        try:
            if manipulator_file.endswith(&#39;.urdf&#39;):
                self.manipulator_uid = p.loadURDF(manipulator_file)
            elif manipulator_file.endswith(&#39;.sdf&#39;):
                self.manipulator_uid = p.loadSDF(manipulator_file)[0]
            else:
                raise InvalidManipulatorFile(&#39;The file extension is neither .sdf nor .urdf&#39;)
        except p.error as err:
            logger.critical(err)
            raise InvalidManipulatorFile

        self.num_joints = p.getNumJoints(self.manipulator_uid)

        logger.debug(f&#39;Robot Manipulator URDF/SDF file {manipulator_file} has been successfully loaded. &#39;
                     f&#39;The Robot Manipulator has {self.num_joints} joints, and its joints, &#39;
                     f&#39;together with the information of each, are:&#39;)
        data = list()
        for joint_ind in range(self.num_joints):
            joint_info = p.getJointInfo(self.manipulator_uid, joint_ind)
            data.append((joint_ind, joint_info[1].decode(&#34;utf-8&#34;), joint_info[9], joint_info[8], joint_info[13]))

        # Print Joints info
        self.print_table(data)

        # Create obstacle with the shape of a sphere, and the target object with square shape
        self.obstacle = p.loadURDF(&#39;sphere_small.urdf&#39;, basePosition=self.obstacle_pos,
                                   useFixedBase=1, globalScaling=2.5)
        self.target = p.loadURDF(&#39;cube_small.urdf&#39;, basePosition=self.target_pos,
                                 useFixedBase=1, globalScaling=1)
        logger.debug(f&#39;Both the obstacle and the target object have been generated in positions {self.obstacle_pos} &#39;
                     f&#39;and {self.target_pos} respectively&#39;)

        # 9 elements correspond to the 3 vector indicating the position of the target, end effector and obstacle
        # The other elements are the two arrays of the involved joint&#39;s position and velocities
        self._observation_space = np.zeros((9 + 2 * len(self.involved_joints),))
        self._action_space = np.zeros((len(self.involved_joints),))

    def reset(self, verbose: bool = True) -&gt; NDArray:
        &#34;&#34;&#34;
        Resets the environment to a initial state.\n
        - If &#34;initial_joint_positions&#34; and &#34;initial_positions_variation_range&#34; are not set, all joints will be reset to
        the 0 position.\n
        - If only &#34;initial_joint_positions&#34; is set, the joints will be reset to those positions.\n
        - If only &#34;initial_positions_variation_range&#34; is set, the joints will be reset to 0 plus the variation noise.\n
        - If both &#34;initial_joint_positions&#34; and &#34;initial_positions_variation_range&#34; are set, the joints will be reset
        to the positions specified plus the variation noise.
        Args:
            verbose: Boolean indicating whether to print context information or not.
        Returns:
            New state reached after reset.
        &#34;&#34;&#34;
        if verbose: logger.info(&#39;Resetting Environment...&#39;)

        # Reset the robot&#39;s base position and orientation
        p.resetBasePositionAndOrientation(self.manipulator_uid, [0.000000, 0.000000, 0.000000],
                                          [0.000000, 0.000000, 0.000000, 1.000000])

        if not self.initial_joint_positions and not self.initial_positions_variation_range:
            initial_state = [0 for _ in range(self.num_joints)]
        elif self.initial_joint_positions:
            if self.initial_positions_variation_range:
                initial_state = [random.uniform(pos - var, pos + var) for pos, var
                                 in zip(self.initial_joint_positions, self.initial_positions_variation_range)]
            else:
                initial_state = self.initial_joint_positions
        else:
            initial_state = [random.uniform(0 - var, 0 + var) for var in self.initial_positions_variation_range]

        for joint_index, pos in enumerate(initial_state):
            p.setJointMotorControl2(self.manipulator_uid, joint_index,
                                    controlMode=p.POSITION_CONTROL,
                                    targetPosition=pos)

        for _ in range(50):
            p.stepSimulation(self.physics_client)

        # Generate first state, and return it
        # The states are defined as {joint_pos, joint_vel, end-effector_pos, target_pos, obstacle_pos}, where
        # both joint_pos and joint_vel are arrays with the pos and vel of each joint
        new_state = self.get_state()
        if verbose: logger.info(&#39;Environment Reset&#39;)

        return new_state

    def is_terminal_state(self, target_threshold: float = 0.05, obstacle_threshold: float = 0.,
                          consider_autocollision: bool = False) -&gt; int:
        &#34;&#34;&#34;
        Calculates if a terminal state is reached.
        Args:
            target_threshold: Threshold which delimits the terminal state. If the end-effector is closer
                to the target position than the threshold value, then a terminal state is reached.
            obstacle_threshold: Threshold which delimits the terminal state. If the end-effector is closer
                to the obstacle position than the threshold value, then a terminal state is reached.
            consider_autocollision: If set to True, the collision of any of the joints and parts of the manipulator
                with any other joint or part will be considered a terminal state.
        Returns:
            Integer (0 or 1) indicating whether the new state reached is a terminal state or not.
        &#34;&#34;&#34;
        # If the manipulator has a collision with the obstacle, the episode terminates
        if self.get_manipulator_obstacle_collisions(threshold=obstacle_threshold):
            logger.info(&#39;Collision detected, terminating episode...&#39;)
            return 1

        # If the position of the end-effector is the same as the one of the target position, episode terminates
        if self.get_endeffector_target_collision(threshold=target_threshold)[0]:
            logger.info(&#39;The goal state has been reached, terminating episode...&#39;)
            return 1

        # If the manipulator collides with itself, a terminal state is reached
        if consider_autocollision:
            self_distances = self.get_manipulator_collisions_with_itself()
            for distances in self_distances.values():
                if (distances &lt; 0).any():
                    logger.info(&#39;Auto-Collision detected, terminating episode...&#39;)
                    return 1

        return 0

    def get_reward(self, consider_autocollision: bool = False) -&gt; float:
        &#34;&#34;&#34;
        Computes the reward from the given state.
        Returns:
            Rewards:\n
            - If the end effector reaches the target position, a reward of +250 is returned.\n
            - If the end effector collides with the obstacle or with itself*, a reward of -1000 is returned.\n
            - Otherwise, the negative value of the distance from end effector to the target is returned.\n
            * The manipulator&#39;s collisions with itself are only considered if &#34;consider_autocollision&#34; parameter is set
            to True.
        &#34;&#34;&#34;
        # Auto-Collision is only calculated if requested
        self_collision = False
        if consider_autocollision:
            self_distances = self.get_manipulator_collisions_with_itself()
            for distances in self_distances.values():
                if (distances &lt; 0).any():
                    self_collision = True

        endeffector_target_collision, endeffector_target_dist = self.get_endeffector_target_collision(threshold=0.05)

        if endeffector_target_collision:
            return 250
        elif self.get_manipulator_obstacle_collisions(threshold=0) or self_collision:
            return -1000
        else:
            return -1 * float(endeffector_target_dist)

    def get_manipulator_obstacle_collisions(self, threshold: float) -&gt; bool:
        &#34;&#34;&#34;
        Calculates if there is a collision between the manipulator and the obstacle.
        Args:
            threshold: If the distance between the end effector and the obstacle is below the &#34;threshold&#34;, then
                it is considered a collision.
        Returns:
            Boolean indicating whether a collision occurred.
        &#34;&#34;&#34;
        joint_distances = list()
        for joint_ind in range(self.num_joints):
            end_effector_collision_obj = CollisionObject(body=self.manipulator_uid, link=joint_ind)
            collision_detector = CollisionDetector(collision_object=end_effector_collision_obj,
                                                   obstacle_ids=[self.obstacle])

            dist = collision_detector.compute_distances()
            joint_distances.append(dist[0])

        joint_distances = np.array(joint_distances)
        return (joint_distances &lt; threshold).any()

    def get_manipulator_collisions_with_itself(self) -&gt; dict:
        &#34;&#34;&#34;
        Calculates the distances between each of the manipulator&#39;s joints and the other joints.
        Returns:
            Dictionary where each key is the index of a joint, and where each value is an array with the
            distances from that joint to any other joint in the manipulator.
        &#34;&#34;&#34;
        joint_distances = dict()
        for joint_ind in range(self.num_joints):
            joint_collision_obj = CollisionObject(body=self.manipulator_uid, link=joint_ind)
            collision_detector = CollisionDetector(collision_object=joint_collision_obj,
                                                   obstacle_ids=[])
            distances = collision_detector.compute_collisions_in_manipulator(
                affected_joints=[_ for _ in range(self.num_joints)],  # all joints are taken into account
                max_distance=10
            )
            joint_distances[f&#39;joint_{joint_ind}&#39;] = distances

        return joint_distances

    def get_endeffector_target_collision(self, threshold: float) -&gt; Tuple[bool, float]:
        &#34;&#34;&#34;
        Calculates if there are any collisions between the end effector and the target.
        Args:
            threshold: If the distance between the end effector and the target is below {threshold}, then
                it is considered a collision.
        Returns:
            Tuple where the first element is a boolean indicating whether a collision occurred, adn where
            the second is the distance from end effector to target minus the threshold.
        &#34;&#34;&#34;
        kuka_end_effector = CollisionObject(body=self.manipulator_uid, link=self.endeffector_index)
        collision_detector = CollisionDetector(collision_object=kuka_end_effector, obstacle_ids=[self.target])

        dist = collision_detector.compute_distances()

        return (dist &lt; threshold).any(), dist - threshold

    def get_state(self) -&gt; NDArray:
        &#34;&#34;&#34;
        Retrieves information from the environment&#39;s current state.
        Returns:
            State as (joint_pos, joint_vel, end-effector_pos, target_pos, obstacle_pos):\n
            - The positions of the target, obstacle and end effector are given as 3D cartesian coordinates.\n
            - The joint positions and joint velocities are given as arrays of length equal to the number of
            joint involved in the training.
        &#34;&#34;&#34;
        joint_pos, joint_vel = list(), list()

        for joint_index in range(len(self.involved_joints)):
            joint_pos.append(p.getJointState(self.manipulator_uid, joint_index)[0])
            joint_vel.append(p.getJointState(self.manipulator_uid, joint_index)[1])

        end_effector_pos = p.getLinkState(self.manipulator_uid, self.endeffector_index)[0]
        end_effector_pos = list(end_effector_pos)

        state = np.hstack([np.array(joint_pos), np.array(joint_vel), np.array(end_effector_pos),
                           np.array(self.target_pos), np.array(self.obstacle_pos)])
        return state.astype(float)

    def step(self, action: NDArray) -&gt; Tuple[NDArray, float, int]:
        &#34;&#34;&#34;
        Applies the action on the Robot&#39;s joints, so that each joint reaches the desired velocity for
        each involved joint.
        Args:
            action: Array where each element corresponds to the velocity to be applied on the joint
                with that same index.
        Returns:
            (new_state, reward, done)
        &#34;&#34;&#34;
        # Apply velocities on the involved joints according to action
        for joint_index, vel in zip(self.involved_joints, action):
            p.setJointMotorControl2(self.manipulator_uid,
                                    joint_index,
                                    p.VELOCITY_CONTROL,
                                    targetVelocity=vel,
                                    force=self.max_force)

        # Create constraint for fixed joints (maintain joint on fixed position)
        for joint_ind in self.fixed_joints:
            p.setJointMotorControl2(self.manipulator_uid,
                                    joint_ind,
                                    p.POSITION_CONTROL,
                                    targetPosition=0)

        # Perform actions on simulation
        p.stepSimulation(physicsClientId=self.physics_client)

        reward = self.get_reward()
        new_state = self.get_state()
        done = self.is_terminal_state()

        return new_state, reward, done

    @staticmethod
    def print_table(data: List[Tuple[int, str, float, float, tuple]]) -&gt; None:
        &#34;&#34;&#34;
        Prints a table such that the elements received in the &#34;data&#34; parameter are displayed under
        &#34;Index&#34;, &#34;Name&#34;, &#34;Upper Limit&#34;, &#34;Lower Limit&#34; and &#34;Axis&#34; columns. It is used to print the Manipulator&#39;s
        joint&#39;s information in an ordered manner.
        Args:
            data: List where each element contains all the information about a given joint.
                Each element on the list will be a tuple containing (index, name, upper_limit, lower_limit, axis).
        &#34;&#34;&#34;
        logger.debug(&#39;{:&lt;6} {:&lt;35} {:&lt;15} {:&lt;15} {:&lt;15}&#39;.format(&#39;Index&#39;, &#39;Name&#39;, &#39;Upper Limit&#39;, &#39;Lower Limit&#39;, &#39;Axis&#39;))
        for index, name, up_limit, lo_limit, axis in data:
            logger.debug(&#39;{:&lt;6} {:&lt;35} {:&lt;15} {:&lt;15} {:&lt;15}&#39;.format(index, name, up_limit, lo_limit, str(axis)))

    @property
    def observation_space(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Getter for the observation space of the environment.
        Returns:
            Numpy array of zeros with same shape as the environment&#39;s states.
        &#34;&#34;&#34;
        return self._observation_space

    @property
    def action_space(self) -&gt; np.ndarray:
        &#34;&#34;&#34;
        Getter for the action space of the environment.
        Returns:
            Numpy array of zeros with same shape as the environment&#39;s actions.
        &#34;&#34;&#34;
        return self._action_space</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.print_table"><code class="name flex">
<span>def <span class="ident">print_table</span></span>(<span>data: List[Tuple[int, str, float, float, tuple]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Prints a table such that the elements received in the "data" parameter are displayed under
"Index", "Name", "Upper Limit", "Lower Limit" and "Axis" columns. It is used to print the Manipulator's
joint's information in an ordered manner.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>data</code></strong></dt>
<dd>List where each element contains all the information about a given joint.
Each element on the list will be a tuple containing (index, name, upper_limit, lower_limit, axis).</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def print_table(data: List[Tuple[int, str, float, float, tuple]]) -&gt; None:
    &#34;&#34;&#34;
    Prints a table such that the elements received in the &#34;data&#34; parameter are displayed under
    &#34;Index&#34;, &#34;Name&#34;, &#34;Upper Limit&#34;, &#34;Lower Limit&#34; and &#34;Axis&#34; columns. It is used to print the Manipulator&#39;s
    joint&#39;s information in an ordered manner.
    Args:
        data: List where each element contains all the information about a given joint.
            Each element on the list will be a tuple containing (index, name, upper_limit, lower_limit, axis).
    &#34;&#34;&#34;
    logger.debug(&#39;{:&lt;6} {:&lt;35} {:&lt;15} {:&lt;15} {:&lt;15}&#39;.format(&#39;Index&#39;, &#39;Name&#39;, &#39;Upper Limit&#39;, &#39;Lower Limit&#39;, &#39;Axis&#39;))
    for index, name, up_limit, lo_limit, axis in data:
        logger.debug(&#39;{:&lt;6} {:&lt;35} {:&lt;15} {:&lt;15} {:&lt;15}&#39;.format(index, name, up_limit, lo_limit, str(axis)))</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.action_space"><code class="name">var <span class="ident">action_space</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Getter for the action space of the environment.</p>
<h2 id="returns">Returns</h2>
<p>Numpy array of zeros with same shape as the environment's actions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def action_space(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Getter for the action space of the environment.
    Returns:
        Numpy array of zeros with same shape as the environment&#39;s actions.
    &#34;&#34;&#34;
    return self._action_space</code></pre>
</details>
</dd>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.observation_space"><code class="name">var <span class="ident">observation_space</span> : numpy.ndarray</code></dt>
<dd>
<div class="desc"><p>Getter for the observation space of the environment.</p>
<h2 id="returns">Returns</h2>
<p>Numpy array of zeros with same shape as the environment's states.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def observation_space(self) -&gt; np.ndarray:
    &#34;&#34;&#34;
    Getter for the observation space of the environment.
    Returns:
        Numpy array of zeros with same shape as the environment&#39;s states.
    &#34;&#34;&#34;
    return self._observation_space</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.get_endeffector_target_collision"><code class="name flex">
<span>def <span class="ident">get_endeffector_target_collision</span></span>(<span>self, threshold: float) ‑> Tuple[bool, float]</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates if there are any collisions between the end effector and the target.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>threshold</code></strong></dt>
<dd>If the distance between the end effector and the target is below {threshold}, then
it is considered a collision.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Tuple where the first element is a boolean indicating whether a collision occurred, adn where
the second is the distance from end effector to target minus the threshold.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_endeffector_target_collision(self, threshold: float) -&gt; Tuple[bool, float]:
    &#34;&#34;&#34;
    Calculates if there are any collisions between the end effector and the target.
    Args:
        threshold: If the distance between the end effector and the target is below {threshold}, then
            it is considered a collision.
    Returns:
        Tuple where the first element is a boolean indicating whether a collision occurred, adn where
        the second is the distance from end effector to target minus the threshold.
    &#34;&#34;&#34;
    kuka_end_effector = CollisionObject(body=self.manipulator_uid, link=self.endeffector_index)
    collision_detector = CollisionDetector(collision_object=kuka_end_effector, obstacle_ids=[self.target])

    dist = collision_detector.compute_distances()

    return (dist &lt; threshold).any(), dist - threshold</code></pre>
</details>
</dd>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.get_manipulator_collisions_with_itself"><code class="name flex">
<span>def <span class="ident">get_manipulator_collisions_with_itself</span></span>(<span>self) ‑> dict</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the distances between each of the manipulator's joints and the other joints.</p>
<h2 id="returns">Returns</h2>
<p>Dictionary where each key is the index of a joint, and where each value is an array with the
distances from that joint to any other joint in the manipulator.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_manipulator_collisions_with_itself(self) -&gt; dict:
    &#34;&#34;&#34;
    Calculates the distances between each of the manipulator&#39;s joints and the other joints.
    Returns:
        Dictionary where each key is the index of a joint, and where each value is an array with the
        distances from that joint to any other joint in the manipulator.
    &#34;&#34;&#34;
    joint_distances = dict()
    for joint_ind in range(self.num_joints):
        joint_collision_obj = CollisionObject(body=self.manipulator_uid, link=joint_ind)
        collision_detector = CollisionDetector(collision_object=joint_collision_obj,
                                               obstacle_ids=[])
        distances = collision_detector.compute_collisions_in_manipulator(
            affected_joints=[_ for _ in range(self.num_joints)],  # all joints are taken into account
            max_distance=10
        )
        joint_distances[f&#39;joint_{joint_ind}&#39;] = distances

    return joint_distances</code></pre>
</details>
</dd>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.get_manipulator_obstacle_collisions"><code class="name flex">
<span>def <span class="ident">get_manipulator_obstacle_collisions</span></span>(<span>self, threshold: float) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates if there is a collision between the manipulator and the obstacle.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>threshold</code></strong></dt>
<dd>If the distance between the end effector and the obstacle is below the "threshold", then
it is considered a collision.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Boolean indicating whether a collision occurred.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_manipulator_obstacle_collisions(self, threshold: float) -&gt; bool:
    &#34;&#34;&#34;
    Calculates if there is a collision between the manipulator and the obstacle.
    Args:
        threshold: If the distance between the end effector and the obstacle is below the &#34;threshold&#34;, then
            it is considered a collision.
    Returns:
        Boolean indicating whether a collision occurred.
    &#34;&#34;&#34;
    joint_distances = list()
    for joint_ind in range(self.num_joints):
        end_effector_collision_obj = CollisionObject(body=self.manipulator_uid, link=joint_ind)
        collision_detector = CollisionDetector(collision_object=end_effector_collision_obj,
                                               obstacle_ids=[self.obstacle])

        dist = collision_detector.compute_distances()
        joint_distances.append(dist[0])

    joint_distances = np.array(joint_distances)
    return (joint_distances &lt; threshold).any()</code></pre>
</details>
</dd>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.get_reward"><code class="name flex">
<span>def <span class="ident">get_reward</span></span>(<span>self, consider_autocollision: bool = False) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Computes the reward from the given state.</p>
<h2 id="returns">Returns</h2>
<p>Rewards:</p>
<ul>
<li>
<p>If the end effector reaches the target position, a reward of +250 is returned.</p>
</li>
<li>
<p>If the end effector collides with the obstacle or with itself*, a reward of -1000 is returned.</p>
</li>
<li>
<p>Otherwise, the negative value of the distance from end effector to the target is returned.</p>
</li>
<li>
<p>The manipulator's collisions with itself are only considered if "consider_autocollision" parameter is set
to True.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_reward(self, consider_autocollision: bool = False) -&gt; float:
    &#34;&#34;&#34;
    Computes the reward from the given state.
    Returns:
        Rewards:\n
        - If the end effector reaches the target position, a reward of +250 is returned.\n
        - If the end effector collides with the obstacle or with itself*, a reward of -1000 is returned.\n
        - Otherwise, the negative value of the distance from end effector to the target is returned.\n
        * The manipulator&#39;s collisions with itself are only considered if &#34;consider_autocollision&#34; parameter is set
        to True.
    &#34;&#34;&#34;
    # Auto-Collision is only calculated if requested
    self_collision = False
    if consider_autocollision:
        self_distances = self.get_manipulator_collisions_with_itself()
        for distances in self_distances.values():
            if (distances &lt; 0).any():
                self_collision = True

    endeffector_target_collision, endeffector_target_dist = self.get_endeffector_target_collision(threshold=0.05)

    if endeffector_target_collision:
        return 250
    elif self.get_manipulator_obstacle_collisions(threshold=0) or self_collision:
        return -1000
    else:
        return -1 * float(endeffector_target_dist)</code></pre>
</details>
</dd>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.get_state"><code class="name flex">
<span>def <span class="ident">get_state</span></span>(<span>self) ‑> numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Retrieves information from the environment's current state.</p>
<h2 id="returns">Returns</h2>
<p>State as (joint_pos, joint_vel, end-effector_pos, target_pos, obstacle_pos):</p>
<ul>
<li>
<p>The positions of the target, obstacle and end effector are given as 3D cartesian coordinates.</p>
</li>
<li>
<p>The joint positions and joint velocities are given as arrays of length equal to the number of
joint involved in the training.</p>
</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_state(self) -&gt; NDArray:
    &#34;&#34;&#34;
    Retrieves information from the environment&#39;s current state.
    Returns:
        State as (joint_pos, joint_vel, end-effector_pos, target_pos, obstacle_pos):\n
        - The positions of the target, obstacle and end effector are given as 3D cartesian coordinates.\n
        - The joint positions and joint velocities are given as arrays of length equal to the number of
        joint involved in the training.
    &#34;&#34;&#34;
    joint_pos, joint_vel = list(), list()

    for joint_index in range(len(self.involved_joints)):
        joint_pos.append(p.getJointState(self.manipulator_uid, joint_index)[0])
        joint_vel.append(p.getJointState(self.manipulator_uid, joint_index)[1])

    end_effector_pos = p.getLinkState(self.manipulator_uid, self.endeffector_index)[0]
    end_effector_pos = list(end_effector_pos)

    state = np.hstack([np.array(joint_pos), np.array(joint_vel), np.array(end_effector_pos),
                       np.array(self.target_pos), np.array(self.obstacle_pos)])
    return state.astype(float)</code></pre>
</details>
</dd>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.is_terminal_state"><code class="name flex">
<span>def <span class="ident">is_terminal_state</span></span>(<span>self, target_threshold: float = 0.05, obstacle_threshold: float = 0.0, consider_autocollision: bool = False) ‑> int</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates if a terminal state is reached.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>target_threshold</code></strong></dt>
<dd>Threshold which delimits the terminal state. If the end-effector is closer
to the target position than the threshold value, then a terminal state is reached.</dd>
<dt><strong><code>obstacle_threshold</code></strong></dt>
<dd>Threshold which delimits the terminal state. If the end-effector is closer
to the obstacle position than the threshold value, then a terminal state is reached.</dd>
<dt><strong><code>consider_autocollision</code></strong></dt>
<dd>If set to True, the collision of any of the joints and parts of the manipulator
with any other joint or part will be considered a terminal state.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>Integer (0 or 1) indicating whether the new state reached is a terminal state or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_terminal_state(self, target_threshold: float = 0.05, obstacle_threshold: float = 0.,
                      consider_autocollision: bool = False) -&gt; int:
    &#34;&#34;&#34;
    Calculates if a terminal state is reached.
    Args:
        target_threshold: Threshold which delimits the terminal state. If the end-effector is closer
            to the target position than the threshold value, then a terminal state is reached.
        obstacle_threshold: Threshold which delimits the terminal state. If the end-effector is closer
            to the obstacle position than the threshold value, then a terminal state is reached.
        consider_autocollision: If set to True, the collision of any of the joints and parts of the manipulator
            with any other joint or part will be considered a terminal state.
    Returns:
        Integer (0 or 1) indicating whether the new state reached is a terminal state or not.
    &#34;&#34;&#34;
    # If the manipulator has a collision with the obstacle, the episode terminates
    if self.get_manipulator_obstacle_collisions(threshold=obstacle_threshold):
        logger.info(&#39;Collision detected, terminating episode...&#39;)
        return 1

    # If the position of the end-effector is the same as the one of the target position, episode terminates
    if self.get_endeffector_target_collision(threshold=target_threshold)[0]:
        logger.info(&#39;The goal state has been reached, terminating episode...&#39;)
        return 1

    # If the manipulator collides with itself, a terminal state is reached
    if consider_autocollision:
        self_distances = self.get_manipulator_collisions_with_itself()
        for distances in self_distances.values():
            if (distances &lt; 0).any():
                logger.info(&#39;Auto-Collision detected, terminating episode...&#39;)
                return 1

    return 0</code></pre>
</details>
</dd>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self, verbose: bool = True) ‑> numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]</span>
</code></dt>
<dd>
<div class="desc"><p>Resets the environment to a initial state.</p>
<ul>
<li>
<p>If "initial_joint_positions" and "initial_positions_variation_range" are not set, all joints will be reset to
the 0 position.</p>
</li>
<li>
<p>If only "initial_joint_positions" is set, the joints will be reset to those positions.</p>
</li>
<li>
<p>If only "initial_positions_variation_range" is set, the joints will be reset to 0 plus the variation noise.</p>
</li>
<li>
<p>If both "initial_joint_positions" and "initial_positions_variation_range" are set, the joints will be reset
to the positions specified plus the variation noise.</p>
</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>verbose</code></strong></dt>
<dd>Boolean indicating whether to print context information or not.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>New state reached after reset.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def reset(self, verbose: bool = True) -&gt; NDArray:
    &#34;&#34;&#34;
    Resets the environment to a initial state.\n
    - If &#34;initial_joint_positions&#34; and &#34;initial_positions_variation_range&#34; are not set, all joints will be reset to
    the 0 position.\n
    - If only &#34;initial_joint_positions&#34; is set, the joints will be reset to those positions.\n
    - If only &#34;initial_positions_variation_range&#34; is set, the joints will be reset to 0 plus the variation noise.\n
    - If both &#34;initial_joint_positions&#34; and &#34;initial_positions_variation_range&#34; are set, the joints will be reset
    to the positions specified plus the variation noise.
    Args:
        verbose: Boolean indicating whether to print context information or not.
    Returns:
        New state reached after reset.
    &#34;&#34;&#34;
    if verbose: logger.info(&#39;Resetting Environment...&#39;)

    # Reset the robot&#39;s base position and orientation
    p.resetBasePositionAndOrientation(self.manipulator_uid, [0.000000, 0.000000, 0.000000],
                                      [0.000000, 0.000000, 0.000000, 1.000000])

    if not self.initial_joint_positions and not self.initial_positions_variation_range:
        initial_state = [0 for _ in range(self.num_joints)]
    elif self.initial_joint_positions:
        if self.initial_positions_variation_range:
            initial_state = [random.uniform(pos - var, pos + var) for pos, var
                             in zip(self.initial_joint_positions, self.initial_positions_variation_range)]
        else:
            initial_state = self.initial_joint_positions
    else:
        initial_state = [random.uniform(0 - var, 0 + var) for var in self.initial_positions_variation_range]

    for joint_index, pos in enumerate(initial_state):
        p.setJointMotorControl2(self.manipulator_uid, joint_index,
                                controlMode=p.POSITION_CONTROL,
                                targetPosition=pos)

    for _ in range(50):
        p.stepSimulation(self.physics_client)

    # Generate first state, and return it
    # The states are defined as {joint_pos, joint_vel, end-effector_pos, target_pos, obstacle_pos}, where
    # both joint_pos and joint_vel are arrays with the pos and vel of each joint
    new_state = self.get_state()
    if verbose: logger.info(&#39;Environment Reset&#39;)

    return new_state</code></pre>
</details>
</dd>
<dt id="robotic_manipulator_rloa.environment.environment.Environment.step"><code class="name flex">
<span>def <span class="ident">step</span></span>(<span>self, action: numpy.ndarray[typing.Any, numpy.dtype[+ScalarType]]) ‑> Tuple[numpy.ndarray[Any, numpy.dtype[+ScalarType]], float, int]</span>
</code></dt>
<dd>
<div class="desc"><p>Applies the action on the Robot's joints, so that each joint reaches the desired velocity for
each involved joint.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action</code></strong></dt>
<dd>Array where each element corresponds to the velocity to be applied on the joint
with that same index.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>(new_state, reward, done)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def step(self, action: NDArray) -&gt; Tuple[NDArray, float, int]:
    &#34;&#34;&#34;
    Applies the action on the Robot&#39;s joints, so that each joint reaches the desired velocity for
    each involved joint.
    Args:
        action: Array where each element corresponds to the velocity to be applied on the joint
            with that same index.
    Returns:
        (new_state, reward, done)
    &#34;&#34;&#34;
    # Apply velocities on the involved joints according to action
    for joint_index, vel in zip(self.involved_joints, action):
        p.setJointMotorControl2(self.manipulator_uid,
                                joint_index,
                                p.VELOCITY_CONTROL,
                                targetVelocity=vel,
                                force=self.max_force)

    # Create constraint for fixed joints (maintain joint on fixed position)
    for joint_ind in self.fixed_joints:
        p.setJointMotorControl2(self.manipulator_uid,
                                joint_ind,
                                p.POSITION_CONTROL,
                                targetPosition=0)

    # Perform actions on simulation
    p.stepSimulation(physicsClientId=self.physics_client)

    reward = self.get_reward()
    new_state = self.get_state()
    done = self.is_terminal_state()

    return new_state, reward, done</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="robotic_manipulator_rloa.environment.environment.EnvironmentConfiguration"><code class="flex name class">
<span>class <span class="ident">EnvironmentConfiguration</span></span>
<span>(</span><span>endeffector_index: int, fixed_joints: List[int], involved_joints: List[int], target_position: List[float], obstacle_position: List[float], initial_joint_positions: List[float] = None, initial_positions_variation_range: List[float] = None, max_force: float = 200.0, visualize: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Validates each of the parameters required for the Environment class initialization.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>endeffector_index</code></strong></dt>
<dd>Index of the manipulator's end-effector.</dd>
<dt><strong><code>fixed_joints</code></strong></dt>
<dd>List containing the indices of every joint not involved in the training.</dd>
<dt><strong><code>involved_joints</code></strong></dt>
<dd>List containing the indices of every joint involved in the training.</dd>
<dt><strong><code>target_position</code></strong></dt>
<dd>List containing the position of the target object, as 3D Cartesian coordinates.</dd>
<dt><strong><code>obstacle_position</code></strong></dt>
<dd>List containing the position of the obstacle, as 3D Cartesian coordinates.</dd>
<dt><strong><code>initial_joint_positions</code></strong></dt>
<dd>List containing as many items as the number of joints of the manipulator.
Each item in the list corresponds to the initial position wanted for the joint with that same index.</dd>
<dt><strong><code>initial_positions_variation_range</code></strong></dt>
<dd>List containing as many items as the number of joints of the manipulator.
Each item in the list corresponds to the variation range wanted for the joint with that same index.</dd>
<dt><strong><code>max_force</code></strong></dt>
<dd>Maximum force to be applied on the joints.</dd>
<dt><strong><code>visualize</code></strong></dt>
<dd>Visualization mode.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class EnvironmentConfiguration:

    def __init__(self,
                 endeffector_index: int,
                 fixed_joints: List[int],
                 involved_joints: List[int],
                 target_position: List[float],
                 obstacle_position: List[float],
                 initial_joint_positions: List[float] = None,
                 initial_positions_variation_range: List[float] = None,
                 max_force: float = 200.,
                 visualize: bool = True):
        &#34;&#34;&#34;
        Validates each of the parameters required for the Environment class initialization.
        Args:
            endeffector_index: Index of the manipulator&#39;s end-effector.
            fixed_joints: List containing the indices of every joint not involved in the training.
            involved_joints: List containing the indices of every joint involved in the training.
            target_position: List containing the position of the target object, as 3D Cartesian coordinates.
            obstacle_position: List containing the position of the obstacle, as 3D Cartesian coordinates.
            initial_joint_positions: List containing as many items as the number of joints of the manipulator.
                Each item in the list corresponds to the initial position wanted for the joint with that same index.
            initial_positions_variation_range: List containing as many items as the number of joints of the manipulator.
                Each item in the list corresponds to the variation range wanted for the joint with that same index.
            max_force: Maximum force to be applied on the joints.
            visualize: Visualization mode.
        &#34;&#34;&#34;
        self._validate_endeffector_index(endeffector_index)
        self._validate_fixed_joints(fixed_joints)
        self._validate_involved_joints(involved_joints)
        self._validate_target_position(target_position)
        self._validate_obstacle_position(obstacle_position)
        self._validate_initial_joint_positions(initial_joint_positions)
        self._validate_initial_positions_variation_range(initial_positions_variation_range)
        self._validate_max_force(max_force)
        self._validate_visualize(visualize)

    def _validate_endeffector_index(self, endeffector_index: int) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;endeffector_index&#34; parameter.
        Args:
            endeffector_index: int
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(endeffector_index, int):
            raise InvalidEnvironmentParameter(&#39;End Effector index received is not an integer&#39;)
        self.endeffector_index = endeffector_index

    def _validate_fixed_joints(self, fixed_joints: List[int]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;fixed_joints&#34; parameter
        Args:
            fixed_joints: list of integers
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(fixed_joints, list):
            raise InvalidEnvironmentParameter(&#39;Fixed Joints received is not a list&#39;)
        for val in fixed_joints:
            if not isinstance(val, int):
                raise InvalidEnvironmentParameter(&#39;An item inside the Fixed Joints list is not an integer&#39;)
        self.fixed_joints = fixed_joints

    def _validate_involved_joints(self, involved_joints: List[int]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;involved_joints&#34; parameter
        Args:
            involved_joints: list of integers
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(involved_joints, list):
            raise InvalidEnvironmentParameter(&#39;Involved Joints received is not a list&#39;)
        for val in involved_joints:
            if not isinstance(val, int):
                raise InvalidEnvironmentParameter(&#39;An item inside the Involved Joints list is not an integer&#39;)
        self.involved_joints = involved_joints

    def _validate_target_position(self, target_position: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;target_position&#34; parameter
        Args:
            target_position: list of floats
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(target_position, list):
            raise InvalidEnvironmentParameter(&#39;Target Position received is not a list&#39;)
        for val in target_position:
            if not isinstance(val, (int, float)):
                raise InvalidEnvironmentParameter(&#39;An item inside the Target Position list is not a float&#39;)
        self.target_position = target_position

    def _validate_obstacle_position(self, obstacle_position: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;obstacle_position&#34; parameter
        Args:
            obstacle_position: list of floats
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(obstacle_position, list):
            raise InvalidEnvironmentParameter(&#39;Obstacle Position received is not a list&#39;)
        for val in obstacle_position:
            if not isinstance(val, (int, float)):
                raise InvalidEnvironmentParameter(&#39;An item inside the Obstacle Position list is not a float&#39;)
        self.obstacle_position = obstacle_position

    def _validate_initial_joint_positions(self, initial_joint_positions: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;initial_joint_positions&#34; parameter
        Args:
            initial_joint_positions: list of floats
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if initial_joint_positions is None:
            self.initial_joint_positions = None
            return
        if not isinstance(initial_joint_positions, list):
            raise InvalidEnvironmentParameter(&#39;Initial Joint Positions received is not a list&#39;)
        for val in initial_joint_positions:
            if not isinstance(val, (int, float)):
                raise InvalidEnvironmentParameter(&#39;An item inside the Initial Joint Positions list is not a float&#39;)
        self.initial_joint_positions = initial_joint_positions

    def _validate_initial_positions_variation_range(self, initial_positions_variation_range: List[float]) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;initial_positions_variation_range&#34; parameter
        Args:
            initial_positions_variation_range: list of floats
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if initial_positions_variation_range is None:
            self.initial_positions_variation_range = None
            return
        if not isinstance(initial_positions_variation_range, list):
            raise InvalidEnvironmentParameter(&#39;Initial Positions Variation Range received is not a list&#39;)
        for val in initial_positions_variation_range:
            if not isinstance(val, (float, int)):
                raise InvalidEnvironmentParameter(&#39;An item inside the Initial Positions Variation Range &#39;
                                                  &#39;list is not a float&#39;)
        self.initial_positions_variation_range = initial_positions_variation_range

    def _validate_max_force(self, max_force: float) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;max_force&#34; parameter
        Args:
            max_force: float
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(max_force, (int, float)):
            raise InvalidEnvironmentParameter(&#39;Maximum Force value received is not a float&#39;)
        self.max_force = max_force

    def _validate_visualize(self, visualize: bool) -&gt; None:
        &#34;&#34;&#34;
        Validates the &#34;visualize&#34; parameter
        Args:
            visualize: bool
        Raises:
            InvalidEnvironmentParameter
        &#34;&#34;&#34;
        if not isinstance(visualize, bool):
            raise InvalidEnvironmentParameter(&#39;Visualize value received is not a boolean&#39;)
        self.visualize = visualize</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="robotic_manipulator_rloa.environment" href="index.html">robotic_manipulator_rloa.environment</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="robotic_manipulator_rloa.environment.environment.Environment" href="#robotic_manipulator_rloa.environment.environment.Environment">Environment</a></code></h4>
<ul class="">
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.action_space" href="#robotic_manipulator_rloa.environment.environment.Environment.action_space">action_space</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.get_endeffector_target_collision" href="#robotic_manipulator_rloa.environment.environment.Environment.get_endeffector_target_collision">get_endeffector_target_collision</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.get_manipulator_collisions_with_itself" href="#robotic_manipulator_rloa.environment.environment.Environment.get_manipulator_collisions_with_itself">get_manipulator_collisions_with_itself</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.get_manipulator_obstacle_collisions" href="#robotic_manipulator_rloa.environment.environment.Environment.get_manipulator_obstacle_collisions">get_manipulator_obstacle_collisions</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.get_reward" href="#robotic_manipulator_rloa.environment.environment.Environment.get_reward">get_reward</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.get_state" href="#robotic_manipulator_rloa.environment.environment.Environment.get_state">get_state</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.is_terminal_state" href="#robotic_manipulator_rloa.environment.environment.Environment.is_terminal_state">is_terminal_state</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.observation_space" href="#robotic_manipulator_rloa.environment.environment.Environment.observation_space">observation_space</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.print_table" href="#robotic_manipulator_rloa.environment.environment.Environment.print_table">print_table</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.reset" href="#robotic_manipulator_rloa.environment.environment.Environment.reset">reset</a></code></li>
<li><code><a title="robotic_manipulator_rloa.environment.environment.Environment.step" href="#robotic_manipulator_rloa.environment.environment.Environment.step">step</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="robotic_manipulator_rloa.environment.environment.EnvironmentConfiguration" href="#robotic_manipulator_rloa.environment.environment.EnvironmentConfiguration">EnvironmentConfiguration</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
